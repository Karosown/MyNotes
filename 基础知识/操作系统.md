> 参考：
>
> [操作系统 三小时速成课 课时2 进程调度_哔哩哔哩_bilibili](https://www.bilibili.com/video/BV1Kd4y1Z7dd?p=2&spm_id_from=pageDriver&vd_source=39ab311d30f9c989c01184bc337556cf)
>
> [(86条消息) 计算机操作系统知识点总结（有这一篇就够了！！！）_原来如此呀的博客-CSDN博客_操作系统](https://blog.csdn.net/Royalic/article/details/119999404)
>
> [(86条消息) 【操作系统】生产者消费者问题_niliushall.的博客-CSDN博客_生产者消费者问题](https://blog.csdn.net/liushall/article/details/81569609)
>
> [(86条消息) 哲学家进餐问题的三种解决方法(C++11)_凌桓丶的博客-CSDN博客_哲学家进餐问题3种代码](https://blog.csdn.net/qq_35423154/article/details/109150852)
>
> 

# 概述

## **什么是操作系统**

*管理计算机硬件和软件资源的系统软件*

- 管理计算机系统的硬软件
- 分配调度资源的系统软件

## 操作系统的目标

方便性、**有效性**、可扩充性、开放性

> 提高系统资源的利用率，提高系统的吞吐量

## 基本功能

- 统一管理计算机资源
  - 处理器资源
  - IO设备资源
  - 存储器资源
  - 文件资源
- 实现计算机资源的抽象
  - IO设备管理软件提供读写接口、文件管理软件提供操作文件接口
- 提供用户与计算机之间的接口
  - GUI
  - 命令行事
  - 系统调用形式

## 特征

最基本的特征，互为存在的条件：并发、共享

- 并发：

  - 指两个和多个事件可以在同一时间间隔发生（同一时间段，但这个事件段很短），宏观的同时，实际交替执行

- 并行：

  - 指两个或多个事件可以在同一时刻（同一个时间点）发生，多个CPU可以实现并行，一个CPU同一时刻只有一个程序在运行，同理可以在单个CPU上实现并发

- 共享：

  OS中的资源可以共多个并发的程序共同使用

  - 互斥共享：当资源被占用时，其他想使用的程序智能等待
  - 同时访问：某种资源并发的被多个程序访问

- 虚拟

  把一个物理实体转变为若干个逻辑实体

  - **时分复用技术**：资源在时间上进行复用，不同程序并发使用，多道程序分时使用计算机的硬件资源，提高资源的利用率。
  - **空分复用技术**：用来实现虚拟磁盘（物理磁盘虚拟为逻辑磁盘，电脑上的C盘、D盘等）、虚拟内存（在逻辑上扩大程序的存储容量）等，提高资源的利用率，提高编程效率。

- 异步

  在多道程序环境下，允许多个进程并发执行，但由于资源等因素的限制，使进程的执行以“停停走走”的方式运行，而且每个进程**执行的情况**（运行、暂停、速度、完成）也是**未知的**。

## 中断处理

中断机制的作用：为了在多道批处理系统中让用户进行交互；

### 一.单道批处理系统

#### 1.概念

![在这里插入图片描述](https://img-blog.csdnimg.cn/2020042915030730.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQzNjA2OTE0,size_16,color_FFFFFF,t_70)

#### 2.特点

- 自动：作业自动运行，无需干预
- 批量：磁带上的各个作业按顺序地进入内存，先调入先完成
- 单道：内存中仅有一道程序运行，可以看成是串行的

#### 3.CPU的利用情况

![在这里插入图片描述](https://img-blog.csdnimg.cn/20200429152109103.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQzNjA2OTE0,size_16,color_FFFFFF,t_70)

分析：外设和CPU交替空闲和忙碌，CPU和外设利用效率低

#### 4.缺点

从单道批处理系统对CPU的利用情况可看出，作业运行过程中若发生IO请求，高速的CPU要等待低速的I/O操作完成，导致CPU资源利用率和系统[吞吐量](https://so.csdn.net/so/search?q=吞吐量&spm=1001.2101.3001.7020)降低。

### 二. 多道批处理系统

#### 1.概念

内存中存放多道程序，当某道程序因某种原因如执行I/O操作时而不能继续运行放弃CPU时，操作系统便调度另一程序运行，这样CPU就尽量忙碌，达到提高系统效率的目的。

#### 2.特点

多道：内存同时存放多道程序
宏观上并行：进入系统的多道程序先后开始了自己的运行，但都未运行完毕
微观上串行：内存中多道程序轮流占有CPU，交替执行

#### 3.CPU的利用情况

![在这里插入图片描述](https://img-blog.csdnimg.cn/20200429152159264.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQzNjA2OTE0,size_16,color_FFFFFF,t_70)


分析：程序A要通过操作系统的调度进行磁盘操作，B则进行磁带操作。当程序A执行I/O请求时，A放弃了CPU，操作系统接着调度B，B开始占用CPU（红宽线）,此时程序A的磁盘操作也在同时进行。

结论：A,B两道程序相互穿插运行，使CPU和外设都尽量忙碌。

#### 4.缺点

- 作业处理时间长
- 交互能力差
- 运行过程不确定

### 其他

![image-20230222020508690](http://gd.7n.cdn.wzl1.top/typora/img/image-20230222020508690.png)

![image-20230222020550785](http://gd.7n.cdn.wzl1.top/typora/img/image-20230222020550785.png)

### 中断产生：

- 发生中断时，CPU立马切换到管态，开展管理工作；（管态又叫特权态，系统态或核心态，是操作系统管理的程序执行时，机器所处的状态。）

- 发生中断后，当前运行的进程回暂停运行，由操作系统内核对中断进行处理；
- 对于不同的中断信号，会进行不同的处理。

### 中断的分类：

- 内中断（也叫“异常”、“例外”、“陷入”）------- 信号来源：CPU内部，与当前执行指令有关；

- 外中断（中断）----------信号来源：CPU外部，与当前执行指令无关。

### 外中断的处理过程：

- 每执行完一个指令后，CPU都需要检查当前是否有外部中断信号；
- 如果检查到外部中断信号，则需要保护被中断进程的CPU环境（如程序状态字PSW，程序计数器PC、各种通用寄存器）把他们存储在PCB（进程控制块中）；
- 根据中断信号类型转入相应的中断处理程序；
- 恢复原进程的CPU环境并退出中断，返回原进程继续执行。

## 其他概念

### 指令

- 特权指令:不允许用户程序使用(只允许操作系统使用)。如IO指令、置中断指令
- 非特权指令:普通的运算指令

### 程序

- 内核程序:系统的管理者，可执行—切指令、运行在核心态
- 应用程序:普通用户程序只能执行非特权指令，运行在用户态

### 处理机状态

- 用户态(目态):CPU只能执行非特权指令
- 核心态(又称管态、内核态):可以执行所有指令用户态到核心态:通过中断（是硬件完成的)
- 核心态到用户态:特权指令psw的标志位 0用户态 1核心态

### 原语

- 处于操作系统的最低层，是最接近硬件的部分。
- 这些程序的运行具有原子性，其操作只能一气呵成
- 这些程序的运行时间都较短，而且调用频繁。

### 中断和异常

- 内中断(异常，信号来自内部)
  - 自愿中断
    - 指令中断
  - 强迫中断
    - 硬件中断
    - 软件中断
- 外中断（中断，信号来着外部)
  - 外设请求
  - 人工干预

### 系统调用

系统给程序员(应用程序)提供的唯一接口，可获得OS的服务。在用户态发生，核心态处理

### 体系结构

- 大内核
- 微内核

# 进程管理

## 进程实体

### 引入进程目的

为了更好地描述和控制程序并发执行，实现操作系统的并发性和共享性（**进程是动态的，程序是静态的**)

### 进程的定义

是计算机中的程序关于某数据集合上的一次运行活动**，**是系统进行资源分配和调度的基本单位（没有引入线程时 ）

### 为什么需要进程：

1. 进程是系统进行**资源分配和调度的基本单位**；
2. 进程作为程序独立运行的载体保障程序正常执行；
3. 进程的存在使得操作系统资源的利用率大幅提升。

### 进程控制块（PCB）

用于描述和控制进程运行的通用数据结构,记录进程当前状态和控制进程运行的全部信息，**是进程存在的唯一标识**。

### **进程（Process）与线程（Thread）**：

- **线程**：操作系统进行**运行调度的最小单位**。
- **进程**：系统进行**资源分配和调度的基本单位**。

**区别与联系**：

- **一个进程可以有一个或多个线程**；
- **线程包含在进程之中，是进程中实际运行工作的单位**；
- **进程的线程共享进程资源**；
- **一个进程可以并发多个线程，每个线程执行不同的任务**。

![image-20210826153718544](https://img-blog.csdnimg.cn/img_convert/57105faf208a76086d4ae131c69d5cc0.png)

##  进程管理五状态模型

- 创建状态：创建进程时**拥有PCB但其它资源尚未就绪**。

- 就绪状态：其它资源（进程控制块、内存、栈空间、堆空间等）都准备好、**只差CPU的状态**。
- 执行状态：**进程获得CPU**，其程序**正在执行**。
- 阻塞状态：进程因**某种原因放弃CPU**的状态，**阻塞进程以队列的形式**放置。
- 终止状态：进程结束由**系统清理或者归还PCB**的状态。

![image-20210830134139425](https://img-blog.csdnimg.cn/img_convert/eeeced482c7813085c3c196d08dda843.png)

## 经典问题

### 生产者-消费者问题

有一群生产者进程在生产产品，并将这些产品提供给消费者进程进行消费，生产者进程和消费者进程可以并发执行，在两者之间设置了一个具有n个缓冲区的缓冲池，生产者进程需要将所生产的产品放到缓冲区中（+1操作），消费者进程可以从缓冲区取走产品消费（-1操作）。

(感觉有点微服务的意思了)![image-20210826155239580](https://img-blog.csdnimg.cn/img_convert/023da6fe44b080b0d69b7cbe3b871a1b.png)

![image-20210826155306444](https://img-blog.csdnimg.cn/img_convert/e285c63164c3cb5f455c0b73d6d0191d.png)

**产生问题**：当两者**并发执行时**可能出差错，导致预期的结果与真实的结果不相符：当执行生产者+1和消费者-1操作之后，**缓冲区的值从10变为了11**。

![image-20210826155457272](https://img-blog.csdnimg.cn/img_convert/3f0978a0e9dc0924328a8159d5396c5a.png)

#### 问题解决

- 在缓冲区为空时，消费者不能再进行消费
- 在缓冲区为满时，生产者不能再进行生产
- 在一个线程进行生产或消费时，其余线程不能再进行生产或消费等操作，即保持线程间的同步
- 注意条件变量与互斥锁的顺序

![这里写图片描述](https://img-blog.csdn.net/20180810210234921?watermark/2/text/aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2xpdXNoYWxs/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70)

由于前两点原因，因此需要保持线程间的同步，即一个线程消费（或生产）完，其他线程才能进行竞争CPU，获得消费（或生产）的机会。对于这一点，可以使用条件变量进行线程间的同步：生产者线程在product之前，需要wait直至获取自己所需的信号量之后，才会进行product的操作；同样，对于消费者线程，在consume之前需要wait直到没有线程在访问共享区（缓冲区），再进行consume的操作，之后再解锁并唤醒其他可用阻塞线程。

![image-20230222023013803](http://gd.7n.cdn.wzl1.top/typora/img/image-20230222023013803.png)

![image-20230222022910958](http://gd.7n.cdn.wzl1.top/typora/img/image-20230222022910958.png)

### 哲学家进餐问题

有5个哲学家，他们的生活方式是交替的思考和进餐，哲学家们共同使用一张圆桌，分别坐在5张椅子上，圆桌上有5只碗和5只筷子。平时哲学家们只进行思考，饥饿时则试图取靠近他们的左右两只筷子，只有两只筷子都被拿到的时候才能进餐，否则等待，进餐完毕后，放下左右筷子进行思考。

![image-20210826155708446](https://img-blog.csdnimg.cn/img_convert/0d2bf6fef66f1a5243c2cf8123683c82.png)

这会导致以下的问题，筷子就相当于临界资源：

**临界资源**指的是一些虽作为共享资源却又无法同时被多个线程共同访问的共享资源。当有进程在使用临界资源时，其他进程必须依据操作系统的同步机制等待占用进程释放该共享资源才可重新竞争使用共享资源。

![image-20210826155818721](https://img-blog.csdnimg.cn/img_convert/3ecb19d823501a56948a61a0def66d6c.png)

#### 问题解决

#### 方法一：当两边的叉子都可用时才拿

当某一个哲学家能够同时拿起左右两只叉子时，才让他拿，这样就能够保证不会因为每个科学家都只拿了一只叉子而导致死锁。

为了保证能够同时拿起，我们需要对拿叉子这一步骤进行加锁，保证哲学家能够同时拿起一双叉子，而不会拿了一边后另一边被人抢走

```cpp
class DiningPhilosophers {
public:
    DiningPhilosophers() 
    {}

    void wantsToEat(int philosopher,
                    function<void()> pickLeftFork,
                    function<void()> pickRightFork,
                    function<void()> eat,
                    function<void()> putLeftFork,
                    function<void()> putRightFork) 
    {
        //对拿叉子进行这一流程进行加锁，保证其能同时拿起一双，而不会被其他人抢走
        _lock.lock();
        _fork[philosopher].lock();
        _fork[(philosopher + 1) % 5].lock();
		_lock.unlock();
		
		//拿起左右叉子
        pickLeftFork();	
        pickRightFork();

        eat();	//吃饭
        
		//放下左右叉子
        putLeftFork();
        putRightFork();
        
        //解锁，让其他人获取叉子
        _fork[philosopher].unlock();
        _fork[(philosopher + 1) % 5].unlock();
    }

private:
    mutex _lock;	
    mutex _fork[5];
};
```

##### 方法二：限制就餐的哲学家数量(或者说，多加一支筷子)

如果要保证至少有一个哲学家能够进餐，那么我们可以采用最简单粗暴的方法，限制人数，只要同时进餐的哲学家不超过四人时，即使在最坏情况下，也至少有一个哲学家能够拿到多出来的那一个叉子。

我们需要用到一个计数器来表示当前就餐的人数，为了保证线程安全我们需要用到一个互斥锁和一个条件变量对其进行保护
```cpp
class DiningPhilosophers {
public:
    DiningPhilosophers()
        :_count(0)
    {}

    void wantsToEat(int philosopher,
                    function<void()> pickLeftFork,
                    function<void()> pickRightFork,
                    function<void()> eat,
                    function<void()> putLeftFork,
                    function<void()> putRightFork) 
    {
        
        unique_lock<mutex> lock(_mtx);
        _cond.wait(lock, [this]()->bool{
            return _count < 4;
        });    //当就餐人数不超过四人的时候允许拿叉子
        ++_count;

        _fork[philosopher].lock();
        _fork[(philosopher + 1) % 5].lock();
        pickLeftFork();
        pickRightFork();

        eat();

        putLeftFork();
        putRightFork();
        _fork[philosopher].unlock();
        _fork[(philosopher + 1) % 5].unlock();

        --_count;
        _cond.notify_one();	//就餐完成，让下一个人进来就餐
    }

private:
    mutex _fork[5];
    mutex _mtx;
    condition_variable _cond;
    int _count;
};
```

##### 	方法三：奇数先左后右，偶数先右后左

由于餐桌是一个如下图的圆环，如果我们此时规定奇数位的哲学家先拿左边的叉子，再拿右边的叉子。而偶数位的哲学家先拿右边的再拿左边的，此时竞争情况如下图所示

![在这里插入图片描述](https://img-blog.csdnimg.cn/20201020201508692.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzM1NDIzMTU0,size_16,color_FFFFFF,t_70#pic_center)

此时2号和3号哲学家争抢3号叉子，4号和5号哲学家争抢5号叉子，1号没有竞争对手，直接获取叉子1。
可以看到，在第一轮中所有哲学家先去争抢奇数叉子，抢到偶数叉子后再去争抢偶数叉子，这样就能够保证至少有一个科学家能够获得两只叉子

```cpp
class DiningPhilosophers {
public:
    DiningPhilosophers()
    {}

    void wantsToEat(int philosopher,
                    function<void()> pickLeftFork,
                    function<void()> pickRightFork,
                    function<void()> eat,
                    function<void()> putLeftFork,
                    function<void()> putRightFork) 
    {
        //如果是奇数则先抢左后抢右
        if(philosopher & 1)
        {
            _fork[philosopher].lock();
            _fork[(philosopher + 1) % 5].lock();
            pickLeftFork();
            pickRightFork();
        }
        //如果是偶数则先抢右后抢左
        else
        {
            _fork[(philosopher + 1) % 5].lock();
            _fork[philosopher].lock();
            pickRightFork();
            pickLeftFork();
            
        }
        eat();  //吃饭

        putLeftFork();  //放下叉子
        putRightFork();
        _fork[philosopher].unlock();
        _fork[(philosopher + 1) % 5].unlock();
    }
private:
    mutex _fork[5];
};
```

## 进程同步

### **进程同步的作用**

对竞争资源在多进程间进行使用次序的协调，使得**并发执行的多个进程之间可以有效使用资源和相互合作**。

### **进程间同步的四原则**：

- **空闲让进**：资源无占用，允许使用；
- **忙则等待**：资源被占用，请求进程等待；
- **有限等待**：保证有限等待时间能够使用资源；
- **让权等待**：等待时，进程需要让出CPU。

### 进程同步的方法

![image-20210826215825209](https://img-blog.csdnimg.cn/img_convert/02681055f8985675efff7bcfc0d06813.png)

#### 使用fork系统调用创建进程

使用fork系统调用无参数，fork会返回两次，分别返回子进程id和0，返回子进程id的是父进程，返回0的是子进程。

如果创建失败，返回-1

![image-20210830162044792](https://img-blog.csdnimg.cn/img_convert/9c0a6ea4132c047a6283bff116554e6d.png)

- fork系统调用是用于创建进程的；
- fork创建的进程初始化状态与父进程一样；
- 系统会为fork的进程分配新的资源

> 子进程一般继承父进程：**用户信息、权限、目录信息、信号信息、环境表、共享存储段和资源限制。**
>
> [(86条消息) 子进程和父进程的关系和示例_xujiali5172923的博客-CSDN博客](https://blog.csdn.net/xujiali5172923/article/details/49591925)
>
> [【Linux 进程】fork父子进程间共享数据分析 - 我得去图书馆了 - 博客园 (cnblogs.com)](https://www.cnblogs.com/xuelisheng/p/10072065.html#:~:text=所谓的父子进程数,的数据同步更改。)
>
> [进程——父子进程共享 - _程序兔 - 博客园 (cnblogs.com)](https://www.cnblogs.com/GuoYuying/p/13304182.html)
>
> （1）父子进程
>
> 子进程通过父进程创建，子进程的结束和父进程的运行是一个异步过程，即父进程永远无法预测子进程什么时候结束。
>
> 当子进程退出的时候，内核会释放子进程所有资源，包括打开的文件，占用的内存等。但是依然会保留部分信息（进程id，退出状态，运行时间），直到父进程通过wait/waitpid来调用获取子进程状态信息后才释放
>
> [(86条消息) 面试中常被问到的（18）父子进程，孤儿进程及僵尸进程_HT . WANG的博客-CSDN博客](https://blog.csdn.net/qq_36131611/article/details/118608842)

##### 孤儿进程

一个父进程退出，而它的一个或多个子进程还在运行，那么那些子进程将成为孤儿进程，孤儿进程将被init进程（1号进程）托管，由init进程负责完成状态收集工作

- IDEA启动SpringBoot项目，关掉IDEA后，SpringBoot（未终止没有断开连接），仍在后台

##### 僵尸进程

通常情况下，子进程退出后，父进程会使用 `wait` 或 `waitpid` 函数进行回收子进程的资源，并获得子进程的终止状态。（如果父进程在子进程结束之前退出，则子进程由init接管。init将会以父进程身份对僵尸状态的子进程进行处理）

但是，如果父进程先于子进程结束，则子进程成为孤儿进程。孤儿进程将被 init 进程（进程号为1）领养，并由 init 进程对孤儿进程完成状态收集工作。

而如果子进程先于父进程退出，同时父进程太忙了，无瑕回收子进程的资源，子进程残留资源（PCB）存放于内核中，变成僵尸（Zombie）进程，如下图所示：

![img](https://img2020.cnblogs.com/other/1218435/202111/1218435-20211114211743830-1369830674.jpg)

>[Linux系统僵尸进程详解 - 良许Linux - 博客园 (cnblogs.com)](https://www.cnblogs.com/yychuyu/p/15553400.html)

### 共享内存

在某种程度上，多进程是共同使用物理内存的，但是由于操作系统的进程管理，进程间的内存空间是独立的，因此进程默认是不能访问进程空间之外的内存空间的。

- 共享存储**允许不相关的进程**访问同一片物理内存；
- 共享内存是两个进程之间**共享和传递数据最快的方式**；
- 共享内存**未提供同步机制**，需要借助其他机制管理访问；

![image-20210826223244411](https://img-blog.csdnimg.cn/img_convert/b99ab3cc36d8e0ae779fa9453cd376d1.png)

### Unix域套接字

域套接字是一种高级的进程间通信的方法，可以用于同一机器进程间通信。

**套接字**（socket）：为网络通信中使用的术语。

Unix系统提供的域套接字提供了网络套接字类似的功能，如Nfinx、uWSGI等。

服务端和客户端分别使用Unix域套接字的过程：

![image-20210826223709480](https://img-blog.csdnimg.cn/img_convert/c79ccc8bc20fc313bb22f9da6984bbd1.png)

## 线程同步

### 线程同步的方法

- **互斥锁**

  互斥锁是最简单的线程同步的方法，也称为互斥量，处于两态之一的变量：**解锁和加锁**，两个状态可以**保证资源访问的串行。** 原子性：指一系列操作**不可被中断**的特性，要么全部执行完成，要么全部没有执行。![image-20210826220013572](https://img-blog.csdnimg.cn/img_convert/10640387866b7ba78ce2f0f7bc953bee.png)目前最常用，也是sync的底层实现

- **自旋锁**

  自旋锁是一种多线程同步的变量，使用自旋锁的线程会**反复检查锁变量是否可用**，自旋锁**不会让出CPU**，是一种**忙等待状态**，即**死循环等待锁被释放**，**自旋锁的效率远高于互斥锁**。特点：**避免了进程或者线程上下文切换的开销**，但是**不适合在单核CPU使用**。

  常见的例子：分布式锁设计

- **读写锁**

  是一种**特殊的自旋锁**，允许**多个读操作同时访问**资源以**提高读性能**，但是**对写操作是互斥的**，即**对多读少写的操作效率提升**很显著。

- **条件变量**

  是一种相对比较复杂的线程同步方法，条件变量允许线程睡眠，直到满足某种条件，当**满足条件时，可以给该线程信号通知唤醒**。

### 线程同步方法的对比

![image-20210826222325975](https://img-blog.csdnimg.cn/img_convert/5db4d976a3d875fa3b377b4b52359cfe.png)


----
![image-20210826222346498](https://img-blog.csdnimg.cn/img_convert/46fba9c2da491e9b54f59a25da320fca.png)

------

![image-20210826222400048](https://img-blog.csdnimg.cn/img_convert/cf863add58ce14b96c9321243b1d29d9.png)

## Linux的进程管理

### 进程类型

- 前台进程：具有终端，可以和用户交互；

- 后台进程：没有占用终端，基本不和用户交互，优先级比前台进程低（将需要执行的命令以“&”符号结束）；

- 守护进程：特殊的后台进程，在系统引导时启动，一直运行直到系统关闭（进程名字以“d”结尾的一般都是守护进程），如crond、sshd、httpd、mysqld…

  >[(86条消息) 带你了解Docker背后的守护进程_董哥的黑板报的博客-CSDN博客](https://blog.csdn.net/qq_41453285/article/details/107358234#:~:text=docker程序,oot身份运行。)

### 进程标记

- **进程ID**：非负整数，进程的唯一标记，每个进程拥有不同的ID；
- **进程的状态标记**：R表示进程处于运行状态，S表示进程处于睡眠状态…

![img](https://img-blog.csdnimg.cn/img_convert/d9db6c96b6624da830ca57bc72b44569.png)

### 操作Linux进程的相关命令：

1. **ps命令**：列出当前的进程，结合-aux可以打印进程的详细信息（ps -aux）；
2. **top命令**：查看所有进程的状态；
3. **kill命令**：给进程发送信号。

# 处理机调度

**处理机是什么？**

简单来说，处理机指的是**硬件**，它包含cpu在内（**早期CPU由运算器和控制器组成，称为中央处理机**），而内核是操作系统中的概念，是操作系统的核心，是属于软件部分。 

- 处理机包括中央处理器，主存储器，输入-输出接口，加接外围设备就构成完整的计算机系统。 
- 处理机是处理计算机系统中存储程序和数据，并按照程序规定的步骤执行指令的部件。
- 程序是描述处理机完成某项任务的指令序列。 指令则是处理机能直接解释、执行的信息单位。

## 概念

是对处理机进行分配，即从就绪队列中按照定的算法(公平、高效)选择一个进程并将处理机分配给它运行，以实现进程并发地执行。

## 分类

- 高级调度（作业调度）

  按一定的原则从外存上处于后备队列的作业中挑选一个（或多个）作业，给他们分配内存等必要资源，并建立相应的进程(建立PCB),以使它（们）获得竟争处理机的权利。

  高级调度是辅存（外存）与内存之间的调度。每个作业只调入一次，调出一次。作业调入时会建立相应的PCB,作业调出时才撤销PCB。高级调度主要是指调入的问题，因为只有调入的时机需要操作系统来确定，但调出的时机必然是作业运行结束才调出。

- 中级调度（内存调度）

  为了使内存中的内存不至于太多，有时需要把某些进程从内存中调到外存。在内存使用情况紧张时，将一些暂时不能运行的进程从内存中对换到外存中等待。当内存有足够的空闲空间时，再将合适的进程重新换入内存。

- 低级调度（进程调度）

  主要任务是按照某种方法和策略从就绪队列中选取一个进程，将处理机分配给它。进程调度是操作系统中最基本的一种调度，在一般的操作系统中都必须配置进程调度。进程调度的频率很高，一般几十毫秒一次。

  >[(86条消息) 三级调度： 高级调度、中级调度、低级调度_彭嘭嘭的博客-CSDN博客_高级调度中级调度低级调度](https://blog.csdn.net/pxypxy27/article/details/117788608)
  >
  >[高级调度（作业调度）、低级调度（进程调度）、中级调度 - 简书 (jianshu.com)](https://www.jianshu.com/p/34516e904d55)

## 调度方式

- 剥夺式（抢占式）：进程1在运行，进程2优先级比进程1高，进程2直接上处理器
  - 原则1：优先级原则，允许**优先级高**的并且是**新到的进程**可以**抢占当前进程的处理机**。
  - 原则2：短进程原则
  - 原则3：时间片原则
- 非剥夺式（非抢占式）：进程1在运行，即使进程2优先级比进程1高，进程2也得等待进程1执行完上处理器

## 调度准则

- CPU利用率

- 系统吞吐量

  单位时间内cpu完成作业的数目

- 周转时间

  作业的完成时间-提交时间

- 等待时间

  进程与等待处理机的时间之和

- 响应时间

  从提交到第一次开始运行的时间

## 算法

### 先来先服务（**FCFS**）：

> **算法原理：**按照作业（进程）到达的先后次序来进行调度，谁先来，谁就先被调度。
>
> **缺点：**忽略了作业的运行时间

### 短作业优先（**SJF**)：

> **算法原理：**以作业的长短来计算优先级，作业越短优先级越高，作业长短以所要求的运行时间来衡量。
>
>  **缺点：**必须预先知道作业的运行时间、对长作业不利，未考虑作业的紧迫程度。

**例题**：

![img](https://i0.hdslb.com/bfs/note/dd0772309e21199871555ef5eddec9d8a95295b0.png)

解：“作业被调度进入运行后不再退出"意为**非抢占式调用**，job2到来时也得等待job1执行完

**①**job1最先达到，运行60分钟，此时job2-6已经全部提交，此时从job2-6中挑选运行时间最短的，那么顺序依次为1→5→6→3→4→2

标准流程如图（要写出作业号、提交时间、运行时间、开始时刻、完成时刻、周转时间）：

![img](https://i0.hdslb.com/bfs/note/b814ab1dff4c2d5500fd50754ac7203378014b36.png)

②周转时间=完成时间-提交时间

平均周转时间=1/n  *(N1+N2+……+Nn）

(n为作业过程总数，N1、N2为周转时间）

### 优先级调度算法：

**算法原理：**FCFS、SJF两种算法都不能反映进程的紧迫程度。而优先级调度算法是外部赋予进程相应的优先级，来体现出进程的紧迫程度，紧迫性进程优先运行

（如何确定优先级：

1、利用某一范围内的一个整数，优先数

2、响应比的大小，谁响应比大，谁优先级就大——高响应比优先调度算法）

### 高响应比优先调度算法

响应比=作业周转时间/作业处理时间=（作业处理时间+作业等待时间）/作业处理时间=1+（作业等待时间/作业处理时间）

### 时间片轮转

适合系统：分时系统

算法原理：基于时间片的轮转，非常公平，就绪队列中的每一个进程每次仅仅运行一个时间片，并且每个进程是轮流运行。

**首先按照FCFS策略把就绪进程排成一个就绪队列，**设置时间片，从第一个进程开始分配处理机，第一个进程的时间片执行完后，再从就绪队列中新的队首进程开始。若进程已经运行完，注意此时第一个进程就已经不在就绪队列的队首，而是从就绪队列中删除。若未执行完只是时间片完了，则是调度程序把它送往末尾去了。

### 多级反馈队列调度算法

**算法原理（调度机制）：**

> 设置多个就绪队列，每个队列赋予不同的优先级，第一个队列优先级最高，并且首先调度最高优先级，也就是第一个队列里面的所有进程，仅当第一个队列空闲时，才开始调度第二个队列中的进程运行。优先级越高的队列，时间片越小。
